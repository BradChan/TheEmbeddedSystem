===========================
2.5 系统的工作模式
===========================

当我们打开桌面计算机系统电源或按下复位按钮之后，大多数情况只是等待OS启动完毕才能继续其他操作，偶尔需要按几个组合键进入特殊的状态，譬如进入BIOS配置状态。
绝大多数现代嵌入式计算机系统也有相似的启动过程，但是正常情况下的启动速度几乎“秒杀”桌面计算机。本节我们将从嵌入式系统通电或复位后开始了解系统的工作状态和工作模式。
虽然细节方面与桌面计算机的启动过程有很大区别，但是工作模式方面却很相似。

嵌入式系统主程序是否带有OS的角度，本节内容包含两种嵌入式系统：带有OS的系统和无OS系统。带有OS的嵌入式系统CPU如何执行OS和应用程序/线程呢？

我们给嵌入式系统通电或复位之后CPU立即开始执行程序。这里有问题：第一条指令在哪个地址空间呢？一旦开始执行指令，CPU的行为或程序的执行结果由编程者事先确定，
甚至将产生可遇见的结果/效果。另一个问题是：OS启动前编程者应该安排CPU做哪些工作？无OS的嵌入式系统在进入主程序之前CPU又应该做哪些工作呢？

嵌入式系统CPU的工作状态和工作模式如图2.25所示，总体上分为2种状态：调试状态和执行指令状态。调试状态是借助于专用的Debug工具，如JTAG工具和Trace工具等，
可以通过设置断点、单步等方法暂停CPU执行指令，并使用调试工具获取CPU内寄存器值和存储器值(含变量和外设)等帮助程序开发者掌握系统内部状态。程序开发者可以
借助于Debug工具强制终止系统CPU停止执行指令或继续执行指令。

现代的嵌入式系统CPU几乎都支持标准JTAG或兼容的调试工具，虽然大多数简单的嵌入式系统软硬件开发并不必需这样的调试步骤，但是这些调试工具都有一种最基本的功能：
固件下载。嵌入式系统软件开发需要经历代码编辑、交叉编译和下载过程，其中下载过程常常使用Debug工具。

.. image:: ../_static/images/c2/mcu_working_mode.jpg
  :scale: 25%
  :align: center

图2.25  嵌入式系统CPU的工作状态和工作模式

抛开调试状态，在正常的指令执行状态中，绝大多数嵌入式系统CPU包含两个工作阶段：引导阶段和正常运行(主程序)阶段。

引导阶段的程序被称作“Bootloader”，这一小片程序将执行一些必要的硬件单元初始化操作，如RAM初始化操作、外部ROM存储器接口初始化操作等，为执行主程序做好准备工作。
在Bootloader，嵌入式系统CPU可能处于两种工作模式：特权的线程模式和异常处理模式。“特权的线程”指的是，这个期间可以用指令访问系统内所有资源。“异常处理”包括软件
和硬件异常、中断请求响应等，除以零是典型的软件异常，非法访问某些存储地址将导致硬件异常。在异常处理模式，绝大多数都是执行中断服务程序响应系统的中断请求，
所有嵌入式系统的软件开发者都会尽可能避免软件或硬件异常，但“万一出现的异常”必须被正确地处理否则将导致系统出现不可预测的行为。为了降低固件下载成本，
部分Bootloader还有DFU(Device Firmware Update)功能以取代专用调试器的程序下载功能，当然这必须借助于专用的DFU软件的支持。譬如，ESP32的Bootloader可以
使用芯片的UART(通用异步收发器)与桌面计算机的ESP-Tools软件连接下载固件，STM32M401和nRF52840的Bootloader都可以直接使用芯片的USB端口与桌面计算机的DFU
软件工具连接下载固件。

如果在执行Bootloader程序阶段无需更新固件则直接开始执行嵌入式系统的主程序。对于无OS的主程序，嵌入式系统CPU分为两个工作模式/状态：特权的线程模式和异常处理模式。
带有OS的主程序，嵌入式系统CPU分为三种工作模式/状态：特权的线程模式、无特权的线程模式和异常处理模式。特权的线程指的是OS，非特权的线程一般是普通应用程序/线程，
两者的主要区别是允许OS访问系统的全部资源而普通应用程序/线程只能访问属于本线程的资源，普通应用程序/线程需要访问系统其他资源时必须借助于OS的某些接口(即API)才行。

图2.25是以ARM Cortex-M系列微内核的MCU为例来说明CPU的工作模式，而RISC-V体系架构的CPU将特权模式和非特权模式分别称作“机器模式(M mode)”和“用户模式(U mode)”，
并增加一种叫做“监督模式(S mode)”，对于嵌入式系统来说只需要RISC-V体系架构的M mode和U mode，如果同时支持三种模式能够实现Unix型OS。

无论名称怎么取，嵌入式系统CPU能够在多种模式下执行指令主要目的是系统资源访问权限管理和资源保护，非特权的模式或用户模式都是为了限制这个模式下CPU执行指令(或用户
程序)的行为。譬如，两个用户线程都会向显示器内存写入数据，如果出现同时向同一地址写入不同数据会出现什么样的结果？原则上带有OS的嵌入式系统软件的系统资源都由OS访问，
CPU在执行用户应用程序/非特权的线程时不能直接访问系统资源，只能借助于OS。

--------------------------

如何进入Bootloader？如何退出Bootloader进入主程序？





--------------------------

参考文献：
::


.. [] https://github.com/espressif/esptool/wiki/Serial-Protocol
